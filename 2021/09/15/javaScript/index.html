<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>javaScript基础知识 | LMW的博客</title><meta name="author" content="codelm,lmwl0113@163.com"><meta name="copyright" content="codelm"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JavaScript一、get 请求传参长度的误区误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。 实际上 HTTP 协议从未规定 GET&#x2F;POST 的请求长度限制是多少。 对 get 请求参数的限制是来源与浏览器或 web 服务器，浏览器或 web 服务器限制了 url 的长度。 为了明确这个概念，我们必须再次强调下面几点: HTTP 协议 未规定 GE">
<meta property="og:type" content="article">
<meta property="og:title" content="javaScript基础知识">
<meta property="og:url" content="http://example.com/2021/09/15/javaScript/index.html">
<meta property="og:site_name" content="LMW的博客">
<meta property="og:description" content="JavaScript一、get 请求传参长度的误区误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。 实际上 HTTP 协议从未规定 GET&#x2F;POST 的请求长度限制是多少。 对 get 请求参数的限制是来源与浏览器或 web 服务器，浏览器或 web 服务器限制了 url 的长度。 为了明确这个概念，我们必须再次强调下面几点: HTTP 协议 未规定 GE">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/img6.jpg">
<meta property="article:published_time" content="2021-09-15T11:31:58.007Z">
<meta property="article:modified_time" content="2021-09-15T11:36:12.601Z">
<meta property="article:author" content="codelm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/img6.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/09/15/javaScript/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'javaScript基础知识',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-09-15 19:36:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/dog.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/img6.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">LMW的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">javaScript基础知识</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-15T11:31:58.007Z" title="发表于 2021-09-15 19:31:58">2021-09-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-09-15T11:36:12.601Z" title="更新于 2021-09-15 19:36:12">2021-09-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="javaScript基础知识"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><h4 id="一、get-请求传参长度的误区"><a href="#一、get-请求传参长度的误区" class="headerlink" title="一、get 请求传参长度的误区"></a>一、get 请求传参长度的误区</h4><p>误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。</p>
<p>实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。</p>
<p>对 get 请求参数的限制是来源与浏览器或 web 服务器，浏览器或 web 服务器限制了 url 的长度。</p>
<p>为了明确这个概念，我们必须再次强调下面几点:</p>
<p>HTTP 协议 未规定 GET 和 POST 的长度限制</p>
<p>GET 的最大长度显示是因为 浏览器和 web 服务器限制了 URI 的长度</p>
<p>不同的浏览器和 WEB 服务器，限制的最大长度不一样</p>
<p>要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte</p>
<h4 id="二、get-和-post-请求在缓存方面的区别"><a href="#二、get-和-post-请求在缓存方面的区别" class="headerlink" title="二、get 和 post 请求在缓存方面的区别"></a>二、get 和 post 请求在缓存方面的区别</h4><p>get 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。</p>
<p>post 不同，post 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。</p>
<p>因此 get 请求适合于请求缓存。</p>
<h4 id="三、闭包"><a href="#三、闭包" class="headerlink" title="三、闭包"></a>三、闭包</h4><p>闭包就是能够读取其他函数内部变量的函数。</p>
<p>只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。</p>
<p>在本质上，闭包是将函数内部和函数外部连接起来的桥梁</p>
<h4 id="四、类的继承"><a href="#四、类的继承" class="headerlink" title="四、类的继承"></a>四、类的继承</h4><p>一、原型链继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = a</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.getA = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.a</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.b = b</span><br><span class="line">&#125;</span><br><span class="line">B.prototype = <span class="keyword">new</span> A(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">B.prototype.constructor = B</span><br><span class="line">B.prototype.getB = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B(<span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ol>
<li>非常纯粹的继承关系，实例是子类的实例，也是父类的实例</li>
<li>父类新增原型方法/原型属性，子类都能访问到</li>
<li>简单，易于实现</li>
</ol>
<p>缺点：</p>
<ol>
<li>要想为子类新增属性和方法，必须要在<code>new Animal()</code>这样的语句之后执行，不能放到构造器中</li>
<li>无法实现多继承</li>
<li>来自原型对象的所有属性被所有实例共享</li>
<li>创建子类实例时，无法向父类构造函数传参</li>
</ol>
<p>二、call 继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = a</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.getA = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.a</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  A.call(<span class="built_in">this</span>, <span class="number">100</span>)</span><br><span class="line">  <span class="built_in">this</span>.b = b</span><br><span class="line">&#125;</span><br><span class="line">B.prototype.constructor = B</span><br><span class="line">B.prototype.getB = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B(<span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ol>
<li>解决了 1 中，子类实例共享父类引用属性的问题</li>
<li>创建子类实例时，可以向父类传递参数</li>
<li>可以实现多继承（call 多个父类对象）</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>实例并不是父类的实例，只是子类的实例</p>
</li>
<li><p>只能继承父类的实例属性和方法，不能继承原型属性/方法</p>
</li>
<li><p>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</p>
</li>
</ol>
<p>三、寄生组合继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = a</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.getA = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.a</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  A.call(<span class="built_in">this</span>)</span><br><span class="line">  <span class="built_in">this</span>.b = b</span><br><span class="line">&#125;</span><br><span class="line">B.prototype = <span class="built_in">Object</span>.create(A.prototype)</span><br><span class="line">B.prototype.constructor = B</span><br><span class="line">B.prototype.getB = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B(<span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>没缺点</p>
<p>四、ES6 继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">a</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.a = a</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getA</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">b</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">this</span>.b = b</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getb</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完美</p>
<h4 id="五、解决异步回调地狱"><a href="#五、解决异步回调地狱" class="headerlink" title="五、解决异步回调地狱"></a>五、解决异步回调地狱</h4><p>promise、generator、async/await</p>
<h4 id="六、前端中的事件流"><a href="#六、前端中的事件流" class="headerlink" title="六、前端中的事件流"></a>六、前端中的事件流</h4><p>HTML 中与 javascript 交互是通过事件驱动来实现的，例如鼠标点击事件 onclick、页面的滚动事件 onscroll 等等，可以向文档或者文档中的元素添加事件侦听器来预订事件。 想要知道这些事件是在什么时候进行调用的，就需要了解一下“事件流”的概念。</p>
<p>什么是事件流：事件流描述的是从页面中接收事件的顺序,DOM2 级事件流包括下面几个阶段。</p>
<p><span style="color:red">事件捕获阶段</span></p>
<p><span style="color:red">处于目标阶段 </span></p>
<p><span style="color:red">事件冒泡阶段</span></p>
<p>addEventListener：addEventListener 是 DOM2 级事件新增的指定事件处理程序的操作</p>
<p>这个方法接收 3 个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。</p>
<p>最后这个布尔值参数如果是 true，表示在捕获阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序。</p>
<p>IE 只支持事件冒泡。</p>
<h4 id="七、如何让事件先冒泡后捕获"><a href="#七、如何让事件先冒泡后捕获" class="headerlink" title="七、如何让事件先冒泡后捕获"></a>七、如何让事件先冒泡后捕获</h4><p>在 DOM 标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获。</p>
<p>通过 e.eventPhase 这个属性可以知道当前的时间是什么阶段</p>
<p>1、捕获阶段</p>
<p>2、目标阶段</p>
<p>3、冒泡阶段</p>
<h4 id="八、如何暂停事件执行"><a href="#八、如何暂停事件执行" class="headerlink" title="八、如何暂停事件执行"></a>八、如何暂停事件执行</h4><ol>
<li>event.preventDefault()</li>
<li>event.stopPropagation()</li>
<li>return false</li>
</ol>
<ul>
<li>event.preventDefault() <strong>阻止特定事件的默认行为</strong>（只有 cancelable 设置为 true 的事件才可以使用），比如：点击 type=”submit” 的 input 标签提交表单，你在 onclick 事件处理中调用 event.preventDefault()方法， 那么在点击 submit 后就不会自动提交表单了。但是并不阻止事件冒泡。</li>
<li>event.stopPropagation() <strong>立即停止事件在 DOM 层次中的传播，即阻止事件冒泡。</strong>但是，并不阻止默认行为。</li>
<li>return false 之后的所有相关的触发事件和动作都不会被执行。<strong>阻止事件继续传播，事件冒泡和默认行为都被阻止。</strong></li>
</ul>
<h4 id="九、事件委托"><a href="#九、事件委托" class="headerlink" title="九、事件委托"></a>九、事件委托</h4><p>简介：事件委托指的是，不在事件的发生地（直接 dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素 DOM 的类型，来做出不同的响应。</p>
<p>举例：最经典的就是 ul 和 li 标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在 li 标签上直接添加，而是在 ul 父元素上添加。</p>
<p>好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。</p>
<h4 id="十、图片的懒加载和预加载"><a href="#十、图片的懒加载和预加载" class="headerlink" title="十、图片的懒加载和预加载"></a>十、图片的懒加载和预加载</h4><p>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。</p>
<p>懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。</p>
<p>两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。</p>
<p>懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p>
<h4 id="十一、mouseover-和-mouseenter-的区别"><a href="#十一、mouseover-和-mouseenter-的区别" class="headerlink" title="十一、mouseover 和 mouseenter 的区别"></a>十一、mouseover 和 mouseenter 的区别</h4><p>mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是 mouseout</p>
<p>mouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是 mouseleave</p>
<h4 id="十二、JS-的-new-操作符做了哪些事情"><a href="#十二、JS-的-new-操作符做了哪些事情" class="headerlink" title="十二、JS 的 new 操作符做了哪些事情"></a>十二、JS 的 new 操作符做了哪些事情</h4><ol>
<li><p>创建一个类的实例：创建一个空对象 obj，然后把这个空对象的<strong>proto</strong>设置为构造函数的 prototype。</p>
</li>
<li><p>初始化实例：构造函数被传入参数并调用，关键字 this 被设定指向该实例 obj。</p>
</li>
<li><p>返回实例 obj。</p>
</li>
</ol>
<h4 id="十三、JS-获取各种位置"><a href="#十三、JS-获取各种位置" class="headerlink" title="十三、JS 获取各种位置"></a>十三、JS 获取各种位置</h4><p>clientHeight：表示的是可视区域的高度，不包含 border 和滚动条</p>
<p>offsetHeight：表示可视区域的高度，包含了 border 和滚动条</p>
<p>scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分。</p>
<p>clientTop：表示边框 border 的厚度，在未指定的情况下一般为 0</p>
<p>scrollTop：滚动后被隐藏的高度，获取对象相对于由 offsetParent 属性指定的父坐标(css</p>
<p>定位的元素或 body 元素)距离顶端的高度。</p>
<h4 id="十四、异步加载-JS-的方法"><a href="#十四、异步加载-JS-的方法" class="headerlink" title="十四、异步加载 JS 的方法"></a>十四、异步加载 JS 的方法</h4><p>defer：只支持 IE 如果您的脚本不会改变文档的内容，可将 defer 属性加入到 script 标签中，以便加快处理文档的速度。因为浏览器知道它将能够安全地读取文档的剩余部分而不用执行脚本，它将推迟对脚本的解释，直到文档已经显示给用户为止。</p>
<p>async，HTML5 属性仅适用于外部脚本，并且如果在 IE 中，同时存在 defer 和 async，那么 defer 的优先级比较高，脚本将在页面完成时执行。</p>
<p>创建 script 标签，插入到 DOM 中</p>
<h4 id="十五、Ajax-解决浏览器缓存问题"><a href="#十五、Ajax-解决浏览器缓存问题" class="headerlink" title="十五、Ajax 解决浏览器缓存问题"></a>十五、Ajax 解决浏览器缓存问题</h4><p>在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)。</p>
<p>在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。</p>
<p>在 URL 后面加上一个随机数： “fresh=” + Math.random()。</p>
<p>在 URL 后面加上时间搓：”nowtime=” + new Date().getTime()。</p>
<p>如果是使用 jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有 ajax</p>
<p>都会执行这条语句就是不需要保存缓存记录。</p>
<h4 id="十六、JS-的节流和防抖"><a href="#十六、JS-的节流和防抖" class="headerlink" title="十六、JS 的节流和防抖"></a>十六、JS 的节流和防抖</h4><h5 id="1、防抖函数"><a href="#1、防抖函数" class="headerlink" title="1、防抖函数"></a>1、防抖函数</h5><p>​ 当持续触发事件一定时间内没有再触发事件事件处理函数才会执行一次如果设定的时间到来之前又一次触发了事件就重新开始延时</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">antiShake</span>(<span class="params">t, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//防抖</span></span><br><span class="line">  <span class="keyword">let</span> time</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    time = <span class="built_in">clearTimeout</span>(time)</span><br><span class="line">    time = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      callback()</span><br><span class="line">    &#125;, t)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsutShake</span>(<span class="params">t, fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//防抖立即执行</span></span><br><span class="line">  <span class="keyword">let</span> time</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(time)</span><br><span class="line">    <span class="keyword">let</span> callNow = !time</span><br><span class="line">    time = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      time = <span class="literal">null</span></span><br><span class="line">    &#125;, t)</span><br><span class="line">    <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">      fn()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用场景</strong> :</p>
<p>​ 使用 echarts 时，改变浏览器宽度的时候，希望重新渲染 echarts 的图像，可以使用此函数，提升性能。（虽然 echarts 里有自带的 resize 函数）<br>​ 典型的案例就是输入搜索:输入结束后 n 秒才进行搜索请求，n 秒内又输入的内容，就重新计时。解决搜索的 bug</p>
<h5 id="2、节流函数"><a href="#2、节流函数" class="headerlink" title="2、节流函数"></a>2、节流函数</h5><p>​ 当持续触发事件的时候保证一段时间内 只调用一次事件处理函数一段时间内 只做一件事情</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//节流</span></span><br><span class="line">  <span class="keyword">let</span> time</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!time) &#123;</span><br><span class="line">      time = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        time = <span class="literal">null</span></span><br><span class="line">        callback()</span><br><span class="line">      &#125;, t)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用场景</strong> :</p>
<p>​ 实际应用表单的提交<br>​ 典型的案例就是鼠标不断点击触发，规定在 n 秒内多次点击只有一次生效。</p>
<h4 id="十七、this-的指向问题"><a href="#十七、this-的指向问题" class="headerlink" title="十七、this 的指向问题"></a>十七、this 的指向问题</h4><h5 id="1、普通函数"><a href="#1、普通函数" class="headerlink" title="1、普通函数"></a>1、普通函数</h5><h5 id="1-、直接调用（fun-）指向-window-function-call-window-参数"><a href="#1-、直接调用（fun-）指向-window-function-call-window-参数" class="headerlink" title="(1)、直接调用（fun()）指向 window function.call(window,参数)"></a>(1)、直接调用（fun()）指向 window function.call(window,参数)</h5><h5 id="2-、对象调用指向调用的对象-object-function-call-object-参数"><a href="#2-、对象调用指向调用的对象-object-function-call-object-参数" class="headerlink" title="(2)、对象调用指向调用的对象 object.function.call(object,参数)"></a>(2)、对象调用指向调用的对象 object.function.call(object,参数)</h5><h5 id="2、箭头函数"><a href="#2、箭头函数" class="headerlink" title="2、箭头函数"></a>2、箭头函数</h5><h5 id="1、概念：箭头函数中，this-指向的固定化，并不是因为箭头函数内部有绑定-this-的机制，实际原因是箭头函数根本没有自己的-this，导致内部的-this-就是外层代码块的-this。正是因为它没有-this，所以也就不能用作构造函数。"><a href="#1、概念：箭头函数中，this-指向的固定化，并不是因为箭头函数内部有绑定-this-的机制，实际原因是箭头函数根本没有自己的-this，导致内部的-this-就是外层代码块的-this。正是因为它没有-this，所以也就不能用作构造函数。" class="headerlink" title="1、概念：箭头函数中，this 指向的固定化，并不是因为箭头函数内部有绑定 this 的机制，实际原因是箭头函数根本没有自己的 this，导致内部的 this 就是外层代码块的 this。正是因为它没有 this，所以也就不能用作构造函数。"></a>1、概念：箭头函数中，this 指向的固定化，并不是因为箭头函数内部有绑定 this 的机制，实际原因是箭头函数根本没有自己的 this，导致内部的 this 就是外层代码块的 this。正是因为它没有 this，所以也就不能用作构造函数。</h5><h5 id="2、箭头函数的-this-指向是指向他的父级"><a href="#2、箭头函数的-this-指向是指向他的父级" class="headerlink" title="2、箭头函数的 this 指向是指向他的父级"></a>2、箭头函数的 this 指向是指向他的父级</h5><h4 id="十八、赋值、浅拷贝、深拷贝区别"><a href="#十八、赋值、浅拷贝、深拷贝区别" class="headerlink" title="十八、赋值、浅拷贝、深拷贝区别"></a>十八、赋值、浅拷贝、深拷贝区别</h4><p><code>var obj = &#123;&#125;</code></p>
<h5 id="上述代码-obj-存储在栈内存中、而-存储在堆内存中、栈指向堆"><a href="#上述代码-obj-存储在栈内存中、而-存储在堆内存中、栈指向堆" class="headerlink" title="上述代码 obj 存储在栈内存中、而 {} 存储在堆内存中、栈指向堆"></a>上述代码 obj 存储在栈内存中、而 {} 存储在堆内存中、栈指向堆</h5><h5 id="1、当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。（下图是赋值理解）"><a href="#1、当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。（下图是赋值理解）" class="headerlink" title="1、当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。（下图是赋值理解）"></a>1、当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。（下图是赋值理解）</h5><img src="/Users/huhu/Library/Application Support/typora-user-images/image-20210323161105488.png" alt="image-20210323161105488" style="zoom:50%;" />

<h5 id="2、浅拷贝-重新在堆中创建内存，拷贝前后对象的基本数据类型五互不影响，但拷贝前后对象的引用类型因共享同一块内存，会相互影响。"><a href="#2、浅拷贝-重新在堆中创建内存，拷贝前后对象的基本数据类型五互不影响，但拷贝前后对象的引用类型因共享同一块内存，会相互影响。" class="headerlink" title="2、浅拷贝:重新在堆中创建内存，拷贝前后对象的基本数据类型五互不影响，但拷贝前后对象的引用类型因共享同一块内存，会相互影响。"></a>2、浅拷贝:重新在堆中创建内存，拷贝前后对象的基本数据类型五互不影响，但拷贝前后对象的引用类型因共享同一块内存，会相互影响。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> target = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(i)) &#123;</span><br><span class="line">      <span class="comment">//obj.hasOwnProperty返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）。</span></span><br><span class="line">      target[i] = obj[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、深拷贝-从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝，拷贝前后的两个对象互不影响。"><a href="#3、深拷贝-从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝，拷贝前后的两个对象互不影响。" class="headerlink" title="3、深拷贝:从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝，拷贝前后的两个对象互不影响。"></a>3、深拷贝:从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝，拷贝前后的两个对象互不影响。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;<span class="comment">//深拷贝</span></span><br><span class="line">	<span class="keyword">let</span> cloneObj = <span class="keyword">new</span> obj.constructor() <span class="comment">//obj.constructor() 返回创建实例对象的 Object 构造函数的引用。注意，此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串。对原始类型来说，如1，true和&quot;test&quot;，该值只可读。</span></span><br><span class="line">	<span class="keyword">if</span> (obj === <span class="literal">null</span>) <span class="keyword">return</span> obj</span><br><span class="line">	<span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj) <span class="comment">//instanceof用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。</span></span><br><span class="line">	<span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj)</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span> obj</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">		<span class="keyword">if</span> (obj.hasOwnProperty(i))&#123;</span><br><span class="line">			cloneObj[i] = deepClone(obj[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cloneObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、图像化概念"><a href="#4、图像化概念" class="headerlink" title="4、图像化概念"></a>4、图像化概念</h5><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">和原数据是否指向同一对象</th>
<th align="center">第一层数据为一般数据类型</th>
<th align="center">第一层数据不是原始数据</th>
</tr>
</thead>
<tbody><tr>
<td align="center">赋值</td>
<td align="center">是</td>
<td align="center">改变会使原始数据一同改变</td>
<td align="center">改变会使原始数据一同改变</td>
</tr>
<tr>
<td align="center">浅拷贝</td>
<td align="center">否</td>
<td align="center">改变不会使原始数据一同改变</td>
<td align="center">改变会使原始数据一同改变</td>
</tr>
<tr>
<td align="center">深拷贝</td>
<td align="center">否</td>
<td align="center">改变不会使原始数据一同改变</td>
<td align="center">改变不会使原始数据一同改变</td>
</tr>
</tbody></table>
<h4 id="十九、JS-中的垃圾回收机制"><a href="#十九、JS-中的垃圾回收机制" class="headerlink" title="十九、JS 中的垃圾回收机制"></a>十九、JS 中的垃圾回收机制</h4><p>必要性：由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。</p>
<p>JavaScript 程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript 的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。</p>
<p>这段话解释了为什么需要系统需要垃圾回收，JS 不像 C/C++，他有自己的一套垃圾回收机制（Garbage Collection）。</p>
<p>JavaScript 的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = b <span class="comment">//这时，会释放掉&quot;hello world&quot;，释放内存以便再引用</span></span><br></pre></td></tr></table></figure>

<p>垃圾回收的方法：标记清除、计数引用。</p>
<p>标记清除：</p>
<p>这是最常见的垃圾回收方式，当变量进入环境时，就标记这个变量为”进入环境“，从逻辑上讲，永远不能释放进入环境的变量所占的内存，只要执行流程进入相应的环境，就可能用到他们。当离开环境时，就标记为离开环境。</p>
<p>垃圾回收器在运行的时候会给存储在内存中的变量都加上标记（所有都加），然后去掉环境变量中的变量，以及被环境变量中的变量所引用的变量（条件性去除标记），删除所有被标记的变量，删除的变量无法在环境变量中被访问所以会被删除，最后垃圾回收器，完成了内存的清除工作，并回收他们所占用的内存。</p>
<p>引用计数法：</p>
<p>引用计数法的意思就是每个值没引用的次数，当声明了一个变量，并用一个引用类型的值赋值给改变量，则这个值的引用次数为 1,</p>
<p>相反的，如果包含了对这个值引用的变量又取得了另外一个值，则原先的引用值引用次数就减 1，当这个值的引用次数为 0 的时候，说明没有办法再访问这个值了，因此就把所占的内存给回收进来，这样垃圾收集器再次运行的时候，就会释放引用次数为 0 的这些值。</p>
<p>用引用计数法会存在内存泄露</p>
<p>下面来看原因：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">problem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> objA = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> objB = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"></span><br><span class="line">  objA.someOtherObject = objB</span><br><span class="line"></span><br><span class="line">  objB.anotherObject = objA</span><br><span class="line"></span><br><span class="line">  <span class="comment">//解决办法</span></span><br><span class="line">  objA = <span class="literal">null</span></span><br><span class="line">  objB = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子里面，objA 和 objB 通过各自的属性相互引用，这样的话，两个对象的引用次数都为 2，在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，因为计数不为 0，这样的相互引用如果大量存在就会导致内存泄露。</p>
<p>特别是在 DOM 对象中，也容易存在这种问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element=<span class="built_in">document</span>.getElementById（<span class="string">&#x27;root&#x27;</span>）；</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObj=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">myObj.element=element;</span><br><span class="line"></span><br><span class="line">element.someObject=myObj;</span><br></pre></td></tr></table></figure>

<p>这样就不会有垃圾回收的过程。</p>
<h4 id="二十、如何理解前端模块化"><a href="#二十、如何理解前端模块化" class="headerlink" title="二十、如何理解前端模块化"></a>二十、如何理解前端模块化</h4><p>​ 前端模块化就是复杂的文件编程一个一个独立的模块，比如 JS 文件等等，分成独立的模块有利于重用（复用性）和维护（版本迭代），这样会引来模块之间相互依赖的问题，所以有了 commonJS 规范，AMD，CMD 规范等等，以及用于 JS 打包（编译等处理）的工具 webpack</p>
<h4 id="二十一、CommonJS、AMD-和-CMD（不标准）"><a href="#二十一、CommonJS、AMD-和-CMD（不标准）" class="headerlink" title="二十一、CommonJS、AMD 和 CMD（不标准）"></a>二十一、CommonJS、AMD 和 CMD（不标准）</h4><p>一个模块是能实现特定功能的文件，有了模块就可以方便的使用别人的代码，想要什么功能就能加载什么模块。</p>
<p>CommonJS：开始于服务器端的模块化，同步定义的模块化，每个模块都是一个单独的作用域，模块输出，modules.exports，模块加载 require()引入模块。</p>
<p>AMD：中文名异步模块定义的意思。requireJS 实现了 AMD 规范，主要用于解决下述两个问题。</p>
<p>1.多个文件有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器</p>
<p>2.加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应的时间越长。</p>
<p>语法：requireJS 定义了一个函数 define，它是全局变量，用来定义模块。</p>
<p>requireJS 的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="built_in">module</span>], callback) <span class="comment">//语法</span></span><br><span class="line"><span class="comment">//定义模块</span></span><br><span class="line">define([<span class="string">&#x27;dependency&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Byron&#x27;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">printName</span>: printName,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载模块</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;math&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>) </span>&#123;</span><br><span class="line">  math.add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>RequireJS 定义了一个函数 define,它是全局变量，用来定义模块：</p>
<p>define(id?dependencies?,factory)</p>
<p>在页面上使用模块加载函数：</p>
<p>require([dependencies],factory)；</p>
<p>总结 AMD 规范：require（）函数在加载依赖函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块加载成功，才会去执行。 因为网页在加载 JS 的时候会停止渲染，因此我们可以通过异步的方式去加载 JS,而如果需要依赖某些，也是异步去依赖，依赖后再执行某些方法。</p>
<h4 id="二十二、实现一个-once-函数，传入函数参数只执行一次"><a href="#二十二、实现一个-once-函数，传入函数参数只执行一次" class="headerlink" title="二十二、实现一个 once 函数，传入函数参数只执行一次"></a>二十二、实现一个 once 函数，传入函数参数只执行一次</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ones</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tag = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag == <span class="literal">true</span>) &#123;</span><br><span class="line">      func.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>)</span><br><span class="line">      tag = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x = ones(a)</span><br><span class="line">x() <span class="comment">// 1</span></span><br><span class="line">x() <span class="comment">// undefind</span></span><br></pre></td></tr></table></figure>

<h4 id="二十三、JS-监听对象属性的改变"><a href="#二十三、JS-监听对象属性的改变" class="headerlink" title="二十三、JS 监听对象属性的改变"></a>二十三、JS 监听对象属性的改变</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1)在 ES5 中可以通过 Object.defineProperty 来实现已有属性的监听</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(user, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 缺点：如果 id 不在 user 对象中，则不能监听 id 的变化</span></span><br><span class="line"><span class="comment">// (2)在 ES6 中可以通过 Proxy 来实现</span></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, value, receiver</span>) </span>&#123;&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 这样即使有属性在 user 中不存在，通过 user.id 来定义也同样可以这样监听这个属性的</span></span><br><span class="line"><span class="comment">// 变化哦。</span></span><br></pre></td></tr></table></figure>

<h4 id="二十四、手写-bind-apply-call-new"><a href="#二十四、手写-bind-apply-call-new" class="headerlink" title="二十四、手写 bind, apply, call, new"></a>二十四、手写 bind, apply, call, new</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.newCall = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//call实现</span></span><br><span class="line">  obj = obj || <span class="built_in">window</span></span><br><span class="line">  obj.fn = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">let</span> newArg = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">let</span> res = obj.fn(...newArg)</span><br><span class="line">  <span class="keyword">delete</span> obj.fn</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.newApply = <span class="function"><span class="keyword">function</span> (<span class="params">obj, arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// apply实现</span></span><br><span class="line">  obj = obj || <span class="built_in">window</span></span><br><span class="line">  obj.fn = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">let</span> res</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) &#123;</span><br><span class="line">    res = obj.fn()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res = obj.fn(...arr)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> obj.fn</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.newBind = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// bind实现</span></span><br><span class="line">  obj = obj || <span class="built_in">window</span></span><br><span class="line">  <span class="keyword">let</span> that = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">let</span> arg = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">let</span> o = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> fun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> totalarg = [...arg, ...arguments]</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> o) &#123;</span><br><span class="line">      that.apply(<span class="built_in">this</span>, totalArg)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      that.apply(obj, totalarg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  o.prototype = that.prototype</span><br><span class="line">  fun.prototype = <span class="keyword">new</span> o()</span><br><span class="line">  <span class="keyword">return</span> fun</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">news</span>(<span class="params">con</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//new实现</span></span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  <span class="comment">//把新对象的原型绑定到构造函数的原型上</span></span><br><span class="line">  <span class="built_in">Object</span>.setPrototypeOf(obj, con.prototype)</span><br><span class="line">  con.apply(obj, [...arguments].slice(<span class="number">1</span>))</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二十五、实现-sleep-的效果"><a href="#二十五、实现-sleep-的效果" class="headerlink" title="二十五、实现 sleep 的效果"></a>二十五、实现 sleep 的效果</h4><p>sleep 效果：执行到某处之后，暂停一段时间后 接着执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//while 循环的方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> start = <span class="built_in">Date</span>.now(),</span><br><span class="line">    expire = start + ms</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">Date</span>.now() &lt; expire);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1111&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行 sleep(1000)之后，休眠了 1000ms 之后输出了 1111。上述循环的方式缺点很明显,容易造成死循环。</span></span><br><span class="line"><span class="comment">//通过 promise 来实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> temple = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">111</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> temple</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">500</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">222</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//先输出了 111，延迟 500ms 后输出 222</span></span><br><span class="line"><span class="comment">//通过 async 封装</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> temple = <span class="keyword">await</span> sleep(<span class="number">1000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1111</span>)</span><br><span class="line">  <span class="keyword">return</span> temple</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line"><span class="comment">//延迟 1000ms 输出了 1111</span></span><br><span class="line"><span class="comment">//通过 generate 来实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">sleep</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">111</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">500</span>)</span><br><span class="line">  .next()</span><br><span class="line">  .value.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2222</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="二十六、JS-判断类型"><a href="#二十六、JS-判断类型" class="headerlink" title="二十六、JS 判断类型"></a>二十六、JS 判断类型</h4><p>判断方法：typeof()，instanceof，Object.prototype.toString.call()</p>
<h4 id="二十七、数组常用方法"><a href="#二十七、数组常用方法" class="headerlink" title="二十七、数组常用方法"></a>二十七、数组常用方法</h4><p>push()，pop()，shift()，unshift()，splice()，sort()，reverse()，map()等</p>
<h4 id="二十八、数组去重"><a href="#二十八、数组去重" class="headerlink" title="二十八、数组去重"></a>二十八、数组去重</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">123</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;, &#123; <span class="attr">a</span>: <span class="string">&#x27;1&#x27;</span> &#125;, &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;, <span class="string">&#x27;meili&#x27;</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//究极去重</span></span><br><span class="line">  <span class="keyword">var</span> b = arr.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(item) <span class="comment">//JSON.stringify(item)是把数组中的对象解析成字符串再比较</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">var</span> c = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(b)) <span class="comment">//Set(b)用来对b去重,去重后大概的样子&#123; &#x27;123&#x27;, &#x27;&#123;&quot;a&quot;:1&#125;&#x27;, &#x27;&#123;&quot;a&quot;:&#123;&quot;b&quot;:1&#125;&#125;&#x27;, &#x27;&#123;&quot;a&quot;:&quot;1&quot;&#125;&#x27;, &#x27;&quot;meili&quot;&#x27; &#125;</span></span><br><span class="line">  <span class="comment">//但是去重后的结果不是我们想要的数组的形式，所以需要用 Array.from()的方法变成我们想要的数组的形式</span></span><br><span class="line">  <span class="keyword">var</span> d = c.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(item)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line">arr = unique(arr)</span><br></pre></td></tr></table></figure>

<h4 id="二十九、JS-实现跨域"><a href="#二十九、JS-实现跨域" class="headerlink" title="二十九、JS 实现跨域"></a>二十九、JS 实现跨域</h4><p><span style="color:red">跨域：</span></p>
<p>跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对 JavaScript 实施的安全限制，那么只要协议、域名、端口有任何一个不同，都被当作是不同的域。跨域原理，即是通过各种方式，避开浏览器的安全限制。</p>
<p><span style="color:red">跨域方法：</span></p>
<p>JSONP：通过动态创建 script，再请求一个带参网址实现跨域通信。</p>
<p>document.domain + iframe 跨域：两个页面都通过 js 强制设置 document.domain 为基础主域，就实现了同域。</p>
<p>location.hash + iframe 跨域：a 欲与 b 跨域相互通信，通过中间页 c 来实现。 三个页面,不同域之间利用 iframe 的 location.hash 传值，相同域之间直接 js 访问来通信。</p>
<p>window.name + iframe 跨域：通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。</p>
<p>postMessage 跨域：可以跨域操作的 window 属性之一。</p>
<p>CORS：服务端设置 Access-Control-Allow-Origin 即可，前端无须设置，若要带 cookie 请</p>
<p>求，前后端都需要设置。</p>
<p>Webpack 代理跨域：启一个代理服务器，实现数据的转发</p>
<h4 id="三十、暂停死区"><a href="#三十、暂停死区" class="headerlink" title="三十、暂停死区"></a>三十、暂停死区</h4><p>在代码块内，使用 let、const 命令声明变量之前，该变量都是不可用的（无法变量提升）。这在语法上，称为“暂时性死区”</p>
<h4 id="三十一、JS-全排列算法"><a href="#三十一、JS-全排列算法" class="headerlink" title="三十一、JS 全排列算法"></a>三十一、JS 全排列算法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">permute</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  dfs([])</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path.length === nums.length) &#123;</span><br><span class="line">      res.push([...path])</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (path.includes(nums[i])) &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      path.push(nums[i])</span><br><span class="line">      dfs(path)</span><br><span class="line">      path.pop()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三十二、什么是按需加载"><a href="#三十二、什么是按需加载" class="headerlink" title="三十二、什么是按需加载"></a>三十二、什么是按需加载</h4><p>当用户触发了动作时才加载对应的功能。触发的动作，是要看具体的业务场景而言，包括但不限于以下几个情况：鼠标点击、输入文字、拉动滚动条，鼠标移动、窗口大小更改等。加载的文件，可以是 JS、图片、CSS、HTML 等。</p>
<h4 id="三十三、Virtual（虚拟）DOM"><a href="#三十三、Virtual（虚拟）DOM" class="headerlink" title="三十三、Virtual（虚拟）DOM"></a>三十三、Virtual（虚拟）DOM</h4><p>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中。</p>
<p>当状态变更的时候，重新构造一棵新的对象树。</p>
<p>然后用新的树和旧的树进行比较，记录两棵树差异，把所记录的差异应用到所构建的真正的 DOM 树上，视图就更新了。</p>
<p>Virtual（虚拟） DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。</p>
<h4 id="三十四、symbol"><a href="#三十四、symbol" class="headerlink" title="三十四、symbol"></a>三十四、symbol</h4><p>Symbol 是 ES6 的新增属性，代表用给定名称作为唯一标识，这种类型的值可以这样创建，let id=symbol(“id”)</p>
<p>Symbl 确保唯一，即使采用相同的名称，也会产生不同的值</p>
<p>我们创建一个字段，仅为知道对应 symbol 的人能访问，使用 symbol 很有用，symbol 并不是 100%隐藏，有内置方法 Object.getOwnPropertySymbols(obj)可以获得所有的 symbol。</p>
<p>也有一个方法 Reflect.ownKeys(obj)返回对象所有的键，包括 symbol。</p>
<p>所以并不是真正隐藏。但大多数库内置方法和语法结构遵循通用约定他们是隐藏的。</p>
<h4 id="三十五、JS-原型链，原型链的顶端是什么？Object-的原型是什么？Object-的原型的原型是什么？在数组原型链上实现删除数组重复数据的方法"><a href="#三十五、JS-原型链，原型链的顶端是什么？Object-的原型是什么？Object-的原型的原型是什么？在数组原型链上实现删除数组重复数据的方法" class="headerlink" title="三十五、JS 原型链，原型链的顶端是什么？Object 的原型是什么？Object 的原型的原型是什么？在数组原型链上实现删除数组重复数据的方法"></a>三十五、JS 原型链，原型链的顶端是什么？Object 的原型是什么？Object 的原型的原型是什么？在数组原型链上实现删除数组重复数据的方法</h4><h4 id="三十六、获得对象上的属性"><a href="#三十六、获得对象上的属性" class="headerlink" title="三十六、获得对象上的属性"></a>三十六、获得对象上的属性</h4><p>从 ES5 开始，有三种方法可以列出对象的属性</p>
<p>for（let I in obj）该方法依次访问一个对象及其原型链中所有可枚举的类型</p>
<p>object.keys: 返回一个数组，包括所有可枚举的属性名称 enumerable: true</p>
<p>object.getOwnPropertyNames: 返回一个数组包含不可枚举的属性 enumerable: false</p>
<h4 id="三十六、JS-加载过程阻塞，解决方法"><a href="#三十六、JS-加载过程阻塞，解决方法" class="headerlink" title="三十六、JS 加载过程阻塞，解决方法"></a>三十六、JS 加载过程阻塞，解决方法</h4><p>指定 script 标签的 async 属性。</p>
<p>如果 async=”async”，脚本相对于页面的其余部分异步地执行（当页面继续进行解析时，脚本将被执行）</p>
<p>如果不使用 async 且 defer=”defer”：脚本将在页面完成解析时执行</p>
<h4 id="三十七、预编译的过程"><a href="#三十七、预编译的过程" class="headerlink" title="三十七、预编译的过程"></a>三十七、预编译的过程</h4><h5 id="1、创建-AO-对象"><a href="#1、创建-AO-对象" class="headerlink" title="1、创建 AO 对象"></a>1、创建 AO 对象</h5><h5 id="2、找形参和变量的声明并且作为-AO-对象的属性名值为-undefind"><a href="#2、找形参和变量的声明并且作为-AO-对象的属性名值为-undefind" class="headerlink" title="2、找形参和变量的声明并且作为 AO 对象的属性名值为 undefind"></a>2、找形参和变量的声明并且作为 AO 对象的属性名值为 undefind</h5><h5 id="3、实参和形参相统一"><a href="#3、实参和形参相统一" class="headerlink" title="3、实参和形参相统一"></a>3、实参和形参相统一</h5><h5 id="4、找函数声明并且覆盖变量的声明"><a href="#4、找函数声明并且覆盖变量的声明" class="headerlink" title="4、找函数声明并且覆盖变量的声明"></a>4、找函数声明并且覆盖变量的声明</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,c</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a)</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line">	<span class="built_in">console</span>.log(a)</span><br><span class="line">	<span class="built_in">console</span>.log(c)</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">false</span>)&#123;</span><br><span class="line">		<span class="keyword">let</span> d = <span class="number">678</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">console</span>.log(d)</span><br><span class="line">	<span class="built_in">console</span>.log(b)</span><br><span class="line">	<span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	<span class="built_in">console</span>.log(b)</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">	<span class="built_in">console</span>.log(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="attr">AO</span>: &#123;</span><br><span class="line">	<span class="attr">a</span>:<span class="literal">undefined</span> <span class="comment">// 1 // function a()&#123;&#125;</span></span><br><span class="line">	<span class="attr">b</span>:<span class="literal">undefined</span></span><br><span class="line">	<span class="attr">c</span>:<span class="literal">undefined</span> <span class="comment">// 2 function c() &#123;&#125;</span></span><br><span class="line">	<span class="attr">d</span>:<span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">ƒ <span class="function"><span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="number">123</span></span><br><span class="line">ƒ <span class="function"><span class="title">c</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">ƒ ()&#123;&#125;</span><br><span class="line">ƒ <span class="function"><span class="title">c</span>(<span class="params"></span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三十八、EventLoop（事件循环机制）"><a href="#三十八、EventLoop（事件循环机制）" class="headerlink" title="三十八、EventLoop（事件循环机制）"></a>三十八、EventLoop（事件循环机制）</h4><p>js 是一门单线程语言，它的异步和多线程的实现是由事件循环机制来实现</p>
<p>EventLoop 由三个部分组成</p>
<p>1、调用栈 (call stack)</p>
<p>2、消息队列 (Message Queue)</p>
<p>3、微任务队列 (Microtack Queue)</p>
<p>函数在执行的时候会被压入调用栈中，被压入的函数叫做帧 (Frame) , 执行完函数中的代码才会被弹出栈</p>
<p>宏任务</p>
<table>
<thead>
<tr>
<th>#</th>
<th align="center">浏览器</th>
<th align="right">Node</th>
</tr>
</thead>
<tbody><tr>
<td>I/O</td>
<td align="center">✅</td>
<td align="right">✅</td>
</tr>
<tr>
<td>setTimeout</td>
<td align="center">✅</td>
<td align="right">✅</td>
</tr>
<tr>
<td>setInterval</td>
<td align="center">✅</td>
<td align="right">✅</td>
</tr>
<tr>
<td>setImmediate</td>
<td align="center">❌</td>
<td align="right">✅</td>
</tr>
<tr>
<td>requestAnimationFrame</td>
<td align="center">✅</td>
<td align="right">❌</td>
</tr>
</tbody></table>
<p>微任务</p>
<table>
<thead>
<tr>
<th>#</th>
<th align="center">浏览器</th>
<th align="right">Node</th>
</tr>
</thead>
<tbody><tr>
<td>process.nextTick</td>
<td align="center">❌</td>
<td align="right">✅</td>
</tr>
<tr>
<td>MutationObserver</td>
<td align="center">✅</td>
<td align="right">❌</td>
</tr>
<tr>
<td>Promise.then catch finally</td>
<td align="center">✅</td>
<td align="right">✅</td>
</tr>
</tbody></table>
<p>只有主函数执行完后才会开始执行微任务，然后再是宏任务</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:lmwl0113@163.com">codelm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/09/15/javaScript/">http://example.com/2021/09/15/javaScript/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">LMW的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/img6.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/09/15/browser/"><img class="prev-cover" src="/img/img15.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">浏览器</div></div></a></div><div class="next-post pull-right"><a href="/2021/09/15/deploy/"><img class="next-cover" src="/img/img13.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">项目打包和自动化部署</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/dog.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">codelm</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript"><span class="toc-number">1.</span> <span class="toc-text">JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81get-%E8%AF%B7%E6%B1%82%E4%BC%A0%E5%8F%82%E9%95%BF%E5%BA%A6%E7%9A%84%E8%AF%AF%E5%8C%BA"><span class="toc-number">1.1.</span> <span class="toc-text">一、get 请求传参长度的误区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81get-%E5%92%8C-post-%E8%AF%B7%E6%B1%82%E5%9C%A8%E7%BC%93%E5%AD%98%E6%96%B9%E9%9D%A2%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.</span> <span class="toc-text">二、get 和 post 请求在缓存方面的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%97%AD%E5%8C%85"><span class="toc-number">1.3.</span> <span class="toc-text">三、闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">1.4.</span> <span class="toc-text">四、类的继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%A7%A3%E5%86%B3%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1"><span class="toc-number">1.5.</span> <span class="toc-text">五、解决异步回调地狱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%89%8D%E7%AB%AF%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-number">1.6.</span> <span class="toc-text">六、前端中的事件流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BA%8B%E4%BB%B6%E5%85%88%E5%86%92%E6%B3%A1%E5%90%8E%E6%8D%95%E8%8E%B7"><span class="toc-number">1.7.</span> <span class="toc-text">七、如何让事件先冒泡后捕获</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%A6%82%E4%BD%95%E6%9A%82%E5%81%9C%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C"><span class="toc-number">1.8.</span> <span class="toc-text">八、如何暂停事件执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">1.9.</span> <span class="toc-text">九、事件委托</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%9B%BE%E7%89%87%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.10.</span> <span class="toc-text">十、图片的懒加载和预加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81mouseover-%E5%92%8C-mouseenter-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.11.</span> <span class="toc-text">十一、mouseover 和 mouseenter 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81JS-%E7%9A%84-new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85"><span class="toc-number">1.12.</span> <span class="toc-text">十二、JS 的 new 操作符做了哪些事情</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81JS-%E8%8E%B7%E5%8F%96%E5%90%84%E7%A7%8D%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.13.</span> <span class="toc-text">十三、JS 获取各种位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD-JS-%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.14.</span> <span class="toc-text">十四、异步加载 JS 的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E4%BA%94%E3%80%81Ajax-%E8%A7%A3%E5%86%B3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98"><span class="toc-number">1.15.</span> <span class="toc-text">十五、Ajax 解决浏览器缓存问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E5%85%AD%E3%80%81JS-%E7%9A%84%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96"><span class="toc-number">1.16.</span> <span class="toc-text">十六、JS 的节流和防抖</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0"><span class="toc-number">1.16.1.</span> <span class="toc-text">1、防抖函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0"><span class="toc-number">1.16.2.</span> <span class="toc-text">2、节流函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E4%B8%83%E3%80%81this-%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98"><span class="toc-number">1.17.</span> <span class="toc-text">十七、this 的指向问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.17.1.</span> <span class="toc-text">1、普通函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E3%80%81%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%EF%BC%88fun-%EF%BC%89%E6%8C%87%E5%90%91-window-function-call-window-%E5%8F%82%E6%95%B0"><span class="toc-number">1.17.2.</span> <span class="toc-text">(1)、直接调用（fun()）指向 window function.call(window,参数)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E3%80%81%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8%E6%8C%87%E5%90%91%E8%B0%83%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1-object-function-call-object-%E5%8F%82%E6%95%B0"><span class="toc-number">1.17.3.</span> <span class="toc-text">(2)、对象调用指向调用的对象 object.function.call(object,参数)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">1.17.4.</span> <span class="toc-text">2、箭头函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%A6%82%E5%BF%B5%EF%BC%9A%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD%EF%BC%8Cthis-%E6%8C%87%E5%90%91%E7%9A%84%E5%9B%BA%E5%AE%9A%E5%8C%96%EF%BC%8C%E5%B9%B6%E4%B8%8D%E6%98%AF%E5%9B%A0%E4%B8%BA%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E6%9C%89%E7%BB%91%E5%AE%9A-this-%E7%9A%84%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%AE%9E%E9%99%85%E5%8E%9F%E5%9B%A0%E6%98%AF%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%A0%B9%E6%9C%AC%E6%B2%A1%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84-this%EF%BC%8C%E5%AF%BC%E8%87%B4%E5%86%85%E9%83%A8%E7%9A%84-this-%E5%B0%B1%E6%98%AF%E5%A4%96%E5%B1%82%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84-this%E3%80%82%E6%AD%A3%E6%98%AF%E5%9B%A0%E4%B8%BA%E5%AE%83%E6%B2%A1%E6%9C%89-this%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B9%9F%E5%B0%B1%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BD%9C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%82"><span class="toc-number">1.17.5.</span> <span class="toc-text">1、概念：箭头函数中，this 指向的固定化，并不是因为箭头函数内部有绑定 this 的机制，实际原因是箭头函数根本没有自己的 this，导致内部的 this 就是外层代码块的 this。正是因为它没有 this，所以也就不能用作构造函数。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84-this-%E6%8C%87%E5%90%91%E6%98%AF%E6%8C%87%E5%90%91%E4%BB%96%E7%9A%84%E7%88%B6%E7%BA%A7"><span class="toc-number">1.17.6.</span> <span class="toc-text">2、箭头函数的 this 指向是指向他的父级</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E5%85%AB%E3%80%81%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB"><span class="toc-number">1.18.</span> <span class="toc-text">十八、赋值、浅拷贝、深拷贝区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8A%E8%BF%B0%E4%BB%A3%E7%A0%81-obj-%E5%AD%98%E5%82%A8%E5%9C%A8%E6%A0%88%E5%86%85%E5%AD%98%E4%B8%AD%E3%80%81%E8%80%8C-%E5%AD%98%E5%82%A8%E5%9C%A8%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%AD%E3%80%81%E6%A0%88%E6%8C%87%E5%90%91%E5%A0%86"><span class="toc-number">1.18.1.</span> <span class="toc-text">上述代码 obj 存储在栈内存中、而 {} 存储在堆内存中、栈指向堆</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%BD%93%E6%88%91%E4%BB%AC%E6%8A%8A%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC%E7%BB%99%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%8F%98%E9%87%8F%E6%97%B6%EF%BC%8C%E8%B5%8B%E7%9A%84%E5%85%B6%E5%AE%9E%E6%98%AF%E8%AF%A5%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9C%A8%E6%A0%88%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%A0%86%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E3%80%82%E4%B9%9F%E5%B0%B1%E6%98%AF%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%8C%87%E5%90%91%E7%9A%84%E6%98%AF%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%EF%BC%8C%E6%97%A0%E8%AE%BA%E5%93%AA%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%8F%91%E7%94%9F%E6%94%B9%E5%8F%98%EF%BC%8C%E5%85%B6%E5%AE%9E%E9%83%BD%E6%98%AF%E6%94%B9%E5%8F%98%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E5%9B%A0%E6%AD%A4%EF%BC%8C%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E8%81%94%E5%8A%A8%E7%9A%84%E3%80%82%EF%BC%88%E4%B8%8B%E5%9B%BE%E6%98%AF%E8%B5%8B%E5%80%BC%E7%90%86%E8%A7%A3%EF%BC%89"><span class="toc-number">1.18.2.</span> <span class="toc-text">1、当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。（下图是赋值理解）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D-%E9%87%8D%E6%96%B0%E5%9C%A8%E5%A0%86%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%86%85%E5%AD%98%EF%BC%8C%E6%8B%B7%E8%B4%9D%E5%89%8D%E5%90%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BA%94%E4%BA%92%E4%B8%8D%E5%BD%B1%E5%93%8D%EF%BC%8C%E4%BD%86%E6%8B%B7%E8%B4%9D%E5%89%8D%E5%90%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%9B%A0%E5%85%B1%E4%BA%AB%E5%90%8C%E4%B8%80%E5%9D%97%E5%86%85%E5%AD%98%EF%BC%8C%E4%BC%9A%E7%9B%B8%E4%BA%92%E5%BD%B1%E5%93%8D%E3%80%82"><span class="toc-number">1.18.3.</span> <span class="toc-text">2、浅拷贝:重新在堆中创建内存，拷贝前后对象的基本数据类型五互不影响，但拷贝前后对象的引用类型因共享同一块内存，会相互影响。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E4%BB%8E%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%AD%E5%BC%80%E8%BE%9F%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%8C%BA%E5%9F%9F%E5%AD%98%E6%94%BE%E6%96%B0%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%AF%B9%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%AD%90%E5%AF%B9%E8%B1%A1%E8%BF%9B%E8%A1%8C%E9%80%92%E5%BD%92%E6%8B%B7%E8%B4%9D%EF%BC%8C%E6%8B%B7%E8%B4%9D%E5%89%8D%E5%90%8E%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%BA%92%E4%B8%8D%E5%BD%B1%E5%93%8D%E3%80%82"><span class="toc-number">1.18.4.</span> <span class="toc-text">3、深拷贝:从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝，拷贝前后的两个对象互不影响。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E5%9B%BE%E5%83%8F%E5%8C%96%E6%A6%82%E5%BF%B5"><span class="toc-number">1.18.5.</span> <span class="toc-text">4、图像化概念</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E4%B9%9D%E3%80%81JS-%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.19.</span> <span class="toc-text">十九、JS 中的垃圾回收机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E3%80%81%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">1.20.</span> <span class="toc-text">二十、如何理解前端模块化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%80%E3%80%81CommonJS%E3%80%81AMD-%E5%92%8C-CMD%EF%BC%88%E4%B8%8D%E6%A0%87%E5%87%86%EF%BC%89"><span class="toc-number">1.21.</span> <span class="toc-text">二十一、CommonJS、AMD 和 CMD（不标准）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-once-%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BC%A0%E5%85%A5%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%8F%AA%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1"><span class="toc-number">1.22.</span> <span class="toc-text">二十二、实现一个 once 函数，传入函数参数只执行一次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%89%E3%80%81JS-%E7%9B%91%E5%90%AC%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E6%94%B9%E5%8F%98"><span class="toc-number">1.23.</span> <span class="toc-text">二十三、JS 监听对象属性的改变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E5%9B%9B%E3%80%81%E6%89%8B%E5%86%99-bind-apply-call-new"><span class="toc-number">1.24.</span> <span class="toc-text">二十四、手写 bind, apply, call, new</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%BA%94%E3%80%81%E5%AE%9E%E7%8E%B0-sleep-%E7%9A%84%E6%95%88%E6%9E%9C"><span class="toc-number">1.25.</span> <span class="toc-text">二十五、实现 sleep 的效果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E5%85%AD%E3%80%81JS-%E5%88%A4%E6%96%AD%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.26.</span> <span class="toc-text">二十六、JS 判断类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%83%E3%80%81%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.27.</span> <span class="toc-text">二十七、数组常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E5%85%AB%E3%80%81%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-number">1.28.</span> <span class="toc-text">二十八、数组去重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B9%9D%E3%80%81JS-%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F"><span class="toc-number">1.29.</span> <span class="toc-text">二十九、JS 实现跨域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E3%80%81%E6%9A%82%E5%81%9C%E6%AD%BB%E5%8C%BA"><span class="toc-number">1.30.</span> <span class="toc-text">三十、暂停死区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E4%B8%80%E3%80%81JS-%E5%85%A8%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95"><span class="toc-number">1.31.</span> <span class="toc-text">三十一、JS 全排列算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E4%BA%8C%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.32.</span> <span class="toc-text">三十二、什么是按需加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E4%B8%89%E3%80%81Virtual%EF%BC%88%E8%99%9A%E6%8B%9F%EF%BC%89DOM"><span class="toc-number">1.33.</span> <span class="toc-text">三十三、Virtual（虚拟）DOM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E5%9B%9B%E3%80%81symbol"><span class="toc-number">1.34.</span> <span class="toc-text">三十四、symbol</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E4%BA%94%E3%80%81JS-%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E9%A1%B6%E7%AB%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FObject-%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FObject-%E7%9A%84%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%9C%A8%E6%95%B0%E7%BB%84%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.35.</span> <span class="toc-text">三十五、JS 原型链，原型链的顶端是什么？Object 的原型是什么？Object 的原型的原型是什么？在数组原型链上实现删除数组重复数据的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E5%85%AD%E3%80%81%E8%8E%B7%E5%BE%97%E5%AF%B9%E8%B1%A1%E4%B8%8A%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.36.</span> <span class="toc-text">三十六、获得对象上的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E5%85%AD%E3%80%81JS-%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E9%98%BB%E5%A1%9E%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">1.37.</span> <span class="toc-text">三十六、JS 加载过程阻塞，解决方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E4%B8%83%E3%80%81%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.38.</span> <span class="toc-text">三十七、预编译的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%88%9B%E5%BB%BA-AO-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.38.1.</span> <span class="toc-text">1、创建 AO 对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E6%89%BE%E5%BD%A2%E5%8F%82%E5%92%8C%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E5%B9%B6%E4%B8%94%E4%BD%9C%E4%B8%BA-AO-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%8D%E5%80%BC%E4%B8%BA-undefind"><span class="toc-number">1.38.2.</span> <span class="toc-text">2、找形参和变量的声明并且作为 AO 对象的属性名值为 undefind</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%AE%9E%E5%8F%82%E5%92%8C%E5%BD%A2%E5%8F%82%E7%9B%B8%E7%BB%9F%E4%B8%80"><span class="toc-number">1.38.3.</span> <span class="toc-text">3、实参和形参相统一</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E6%89%BE%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%B9%B6%E4%B8%94%E8%A6%86%E7%9B%96%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">1.38.4.</span> <span class="toc-text">4、找函数声明并且覆盖变量的声明</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E5%85%AB%E3%80%81EventLoop%EF%BC%88%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="toc-number">1.39.</span> <span class="toc-text">三十八、EventLoop（事件循环机制）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/09/15/css/" title="CSS"><img src="/img/img11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSS"/></a><div class="content"><a class="title" href="/2021/09/15/css/" title="CSS">CSS</a><time datetime="2021-09-15T11:41:09.611Z" title="发表于 2021-09-15 19:41:09">2021-09-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/15/browser/" title="浏览器"><img src="/img/img15.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="浏览器"/></a><div class="content"><a class="title" href="/2021/09/15/browser/" title="浏览器">浏览器</a><time datetime="2021-09-15T11:38:04.546Z" title="发表于 2021-09-15 19:38:04">2021-09-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/15/javaScript/" title="javaScript基础知识"><img src="/img/img6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="javaScript基础知识"/></a><div class="content"><a class="title" href="/2021/09/15/javaScript/" title="javaScript基础知识">javaScript基础知识</a><time datetime="2021-09-15T11:31:58.007Z" title="发表于 2021-09-15 19:31:58">2021-09-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/15/deploy/" title="项目打包和自动化部署"><img src="/img/img13.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="项目打包和自动化部署"/></a><div class="content"><a class="title" href="/2021/09/15/deploy/" title="项目打包和自动化部署">项目打包和自动化部署</a><time datetime="2021-09-15T11:17:38.738Z" title="发表于 2021-09-15 19:17:38">2021-09-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/15/%20createProject/" title="项目搭建规范"><img src="/img/img3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="项目搭建规范"/></a><div class="content"><a class="title" href="/2021/09/15/%20createProject/" title="项目搭建规范">项目搭建规范</a><time datetime="2021-09-15T11:15:32.892Z" title="发表于 2021-09-15 19:15:32">2021-09-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/img6.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By codelm</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>